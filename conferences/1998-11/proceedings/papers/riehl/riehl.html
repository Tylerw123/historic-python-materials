<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD>
<BASE HREF="http://www.foretec.com/python/workshops/1998-11/proceedings/papers/riehl/riehl.html">

<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="http://web.archive.org/web/20010702174220/http://www.foretec.com/python/workshops/1998-11/proceedings/papers/riehl/PyFront.css">
<TITLE> PyFront: Conversion of Python to C Extension Modules</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>

<CENTER>
<H1 CLASS="Title">
<A NAME="pgfId=997359">
 </A>
PyFront: Conversion of Python to C Extension Modules</H1>
<P CLASS="Body">
<A NAME="pgfId=997360">
 </A>
<A HREF="mailto:Jonathan.D.Riehl@usahq.unitedspacealliance.com">Jonathan Riehl</A><br>
<A HREF="http://www.unitedspacealliance.com/">United Space Alliance</A><br>
July 16, 1998</P>
</CENTER>
<HR>

<P CLASS="Body" ALIGN="center">
<A NAME="pgfId=997365">
 </A>
<i>Abstract</i>
</P>
<P CLASS="Body">
<A NAME="pgfId=997367">
 </A>
	PyFront is a system for the conversion of Python modules into
        C extension modules.  PyFront is related to the Paths static
        analysis tool for Python, but employs a higher fidelity data
        flow model.  In building these higher fidelity models, PyFront
        bridges the gap between the interpreted Python language, and
        the compiled C language.  The C extension modules generated by
        PyFront will provide faster execution times but identical
        results to the original Python source.  PyFront has the
        potential to offer an intermediate, but automatic, step in the
        optimization of Python modules and routines.</P>
<HR>

<CENTER>
<I>
Contents
</I>
</CENTER>
<UL>
        <LI><A HREF="#Objectives">Objectives</A></LI>
        <LI><A HREF="#Origins">Origins</A></LI>
        <LI><A HREF="#Methodology">Methodology</A>
          <UL>
            <LI><A HREF="#Methodology_1">The Python Evaluation
                Loop</A></LI>
            <LI><A HREF="#Methodology_2">Basic Block Analysis</A></LI>
            <LI><A HREF="#Methodology_3">Data Flow Analysis</A></LI>
            <LI><A HREF="#Methodology_4">An Example of Symbolic
                Execution</A></LI>
          </UL>
        </LI>
        <LI><A HREF="#Code">Code Generation</A></LI>
        <LI><A HREF="#Results">Results</A></LI>
        <LI><A HREF="#Future">Future Directions</A></LI>
        <LI><A HREF="#Conclusion">Conclusion</A></LI>
        <LI><A HREF="#Works">Works Cited</A></LI>
        <LI><A HREF="#Data">Benchmark Data</A></LI>
</UL>
<HR>

<DIV>
<H2 CLASS="Heading1">
<A NAME="pgfId=997371">
 </A>
<A NAME="Objectives"></A>
Objectives</H2>
<P CLASS="Body">
<A NAME="pgfId=997372">
 </A>
	PyFront is designed to be a system for increasing the Python language's utility as a rapid application development tool.  Using PyFront, working Python code can be translated into faster C code.  The primary objective of PyFront is to minimize or eliminate any overhead added to execution times due to the interpretation of Python byte code and the frame stack.  Additionally, PyFront has been designed with the following objectives in mind:</P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId=997373">
 </A>
Non-intrusive:  The system should not require a developer to add any special code or create separate scripts for it to provide immediate benefit.  If extra constructs were required or optionally available, they should not affect the operation of the original Python code input into the system.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997374">
 </A>
Compatible: The system should be syntactically compatible with the Python language.  Any source module that was compatible with a given version of Python would be a valid input to the system. Furthermore, the system should not operate on syntactically incorrect source.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997375">
 </A>
Modular: The system should be designed to be used from the command line, allowing it to be incorporated into a build utility and/or an integrated development environment.  The system should not require any additional user interaction than an input Python file name.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997376">
 </A>
Optionally typed:  The system should offer optional type constructs that would assist in the generation of optimized (faster and/or smaller) C code.  The typing constructs should also provide better type safety, enabling the Python analysis phase to act in a similar fashion as the lint utility for C.</LI>
</UL>
</DIV>
<DIV>
<H2 CLASS="Heading1">
<A NAME="pgfId=997377">
 </A>
<A NAME="Origins"></A>
Origins</H2>
<P CLASS="Body">
<A NAME="pgfId=997378">
 </A>
	PyFront was conceived after some discussion of a &quot;Python compiler&quot; took place on the USENET.  The brunt of the discussion was over the feasibility of a static Python compiler.  Near the end of the thread, some had concluded that the most feasible approach to Python translation and analysis was something that was not quite a compiler, but not an interpreter (termed then as a &quot;space potato.&quot;)  The implicit use of such a system would be for generating faster executables from Python code.</P>
<P CLASS="Body">
<A NAME="pgfId=997379">
 </A>
	The PyFront system is also related to work done for the GRAD and Paths systems that were under development during PyFront's inception [Fly].  PyFront borrows many of the objectives in the previous section from GRAD.  GRAD, or Grammar-based Rapid Application Development, uses language grammars to drive automatic interface generation for extending Python.  Acting like GRAD in reverse, PyFront uses Python's grammar to automatically build C extension modules.  The Paths test automation system, a testing tool and direct descendant of the GRAD system, was designed to perform the majority of the analysis chores that PyFront uses.  While Paths builds lower fidelity models (computation is abstracted to a set of &quot;ideal&quot; operations, causing the model to lose some accuracy,) it also served as a proof of concept for static data flow analysis of Python code.  What would be required was the application of Paths technology to build higher fidelity models.  These high fidelity mod!
els would then be used in the gene
ration of similar or equivalent C code, with the added bonus of code optimization, a by-product of the data flow model employed [Weise, et. al.]</P>
</DIV>
<DIV>
<H2 CLASS="Heading1">
<A NAME="pgfId=997381">
 </A>
<A NAME="70765">
 </A>
<A NAME="Methodology"></A>
Methodology</H2>
<P CLASS="Body">
<A NAME="pgfId=997382">
 </A>
	The primary methodology used in the development of PyFront consisted of analysis of the Python interpreter.  Once the C basis of Python was understood, control and data flow models could be associated with Python operation.  The most obvious model for control flow analysis centers around partitioning input code into basic blocks and building a control flow graph [Aho, et. al.]   However, the data flow models used in prior systems would be more applicable to optimization, an intended use of the PyFront system.  The following subsections discuss inquiry made into the Python interpreter's operation, as well various representations considered for use in Python translation.</P>
<DIV>
<A NAME="33625"></A>
<MAP NAME="PyFront-1">
</MAP>
<IMG SRC="PyFront-1.gif" USEMAP="#PyFront-1">
</DIV>
<DIV>
<H3 CLASS="Heading2">
<A NAME="pgfId=997414">
 </A>
<A NAME="Methodology_1"></A>
The Python Evaluation Loop</H3>
<P CLASS="Body">
<A NAME="pgfId=997418">
 </A>
	<A HREF="PyFront.html#33625" CLASS="XRef">Figure 1</A>
 illustrates the exact routines used by Python and the intermediate data structures generated during the first time execution of a Python module (during subsequent executions, the byte code object is saved and reused, saving the time spent parsing the code.)  A system to generate C code would need to mimic these routines, first generating an abstract syntax tree, then determine the byte code for the given syntax tree, and finally generate code that would carry out the sequence of instructions represented in the byte code.</P>
<P CLASS="Body">
<A NAME="pgfId=997419">
 </A>
	One particular aid in the analysis of the interpreter process is the exposure of some of these routines in the Python standard library.  In an introspective fashion, the parse tree and the byte code of most Python constructs may be examined in the interpreter itself.  Specifically, the parser module allows the generation of abstract syntax trees, while the dis module allows Python byte code objects to be &quot;disassembled&quot; and their constituent byte code to be viewed on an instruction by instruction basis.</P>
<P CLASS="Body">
<A NAME="pgfId=997420">
 </A>
	Since Python is capable of building abstract syntax trees, and handling byte code objects directly, all that remains to be analyzed is the code in the byte code interpreter.  The interpreter (located in the Python/ceval.c source module) runs as a loop, handling byte code instructions one at a time.</P>
<P CLASS="Body">
<A NAME="pgfId=997421">
 </A>
	Like a modern CPU, the interpreter loop keeps an instruction
            pointer, and has exception and error logic that halts
            script execution when a problem occurs.  The evaluation
            loop isolates each instruction as a literal byte value and
            then takes an action based on the byte code encountered.
            The actions taken are to be found in a switch statement
            that references the entire Python byte code set as individual
            case statements.  From these case statements are calls to
            the Python API [Van Rossum], with arguments to the
            functions either to be found in a stack or as an
            additional set of byte codes, following the operation's
            coded value.</P>

<P CLASS="Body">
<A NAME="pgfId=997422">
 </A>
	Looking at the Python world from &quot;in the loop&quot; shows that as long as the Python data elements (which are always PyObject pointers in the C code) and byte code arguments are managed correctly, there is no difference between running the byte codes and making the Python API calls.  If one were to walk Python byte code and emit the code found in the Python evaluation loop for the given code, there would be no difference to Python.  The Python API was designed to easily interface with C code, allowing extension modules to be written in the faster C language, compiled into shared libraries and then imported into the Python interpreter.</P>
</DIV>
<DIV>
<H3 CLASS="Heading2">
<A NAME="pgfId=997423">
 </A>
<A NAME="Methodology_2"></A>
Basic Block Analysis</H3>
<P CLASS="Body">
<A NAME="pgfId=997424">
 </A>
	There is a catch to an &quot;evaluation loop inlining&quot; strategy.  There are byte codes that jump to different locations in the byte code string, not just the next byte code.  There is a byte code to return from a function, returning control to a higher level Python function or the interpreter itself.  There is an op code that raises exceptions which break out of the evaluation loop.  Exceptions may also occur after any given API call, and require an extension routine in C to stop what it is doing, deinitialize any data being used in the function, and return immediately.</P>
<P CLASS="Body">
<A NAME="pgfId=997425">
 </A>
	In order to handle these problems, the inlining routine would simply have to keep track of where the jump and raise instructions were (essentially partitioning the code into a set of basic blocks,) and where their targets were.  In cases where the function being converted has no try-finally or try-except constructs, the following procedures would apply:</P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId=997426">
 </A>
Emit a function prologue, that will load the argument variables correctly.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997427">
 </A>
When an operation breaks from the evaluation routine, insert a goto instruction to an error handling section at the end of the function.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997428">
 </A>
When an unconditional jump is found, insert a label (such as &quot;dest001:&quot;) before the code generated for the target instruction.  Then emit a C goto instruction to the label inserted.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997429">
 </A>
When a conditional jump is found, insert a label at the code generated for its destination operation.  Then emit a C &quot;if&quot; structure identical to the Python code, but replace the instruction pointer adjusting code with a goto to the label emitted.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997430">
 </A>
Emit an error and/or return section at the end of the function.  The section(s) would be preceded by the label(s) referred to by any exits generated above.  The section(s) would implement the exception and return logic found at the end of the Python evaluation loop.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=997431">
 </A>
	The generated C code would take the interpreter logic and copy
              parts of it for each byte code instruction.  It would
              only remove the necessity of regenerating and
              maintaining byte code (remember that this must now be
              handled by the developer using the inline processor and
              then a C compiler, which would be slower,) in addition
              to the minimal overhead of looping over the byte codes.
              Furthermore, it still ties us to the object stack, with
              inlined code pushing and popping values, unaware of the
              PyObject structures used by neighbor instructions (this
              is illustrated in <A HREF="PyFront.html#57600"
                CLASS="XRef">figure 2</A>
              .)</P>
<DIV>
<A NAME="57600"></A>
<MAP NAME="PyFront-2">
</MAP>
<IMG SRC="PyFront-2.gif" USEMAP="#PyFront-2">
</DIV>
</DIV>
<DIV>
<H3 CLASS="Heading2">
<A NAME="pgfId=997476">
 </A>
<A NAME="Methodology_3"></A>
Data Flow Analysis</H3>
<P CLASS="Body">
<A NAME="pgfId=997480">
 </A>
	<A HREF="PyFront.html#57600" CLASS="XRef">Figure 2</A>
 shows various aspects of the data flow within a Python session, in addition to depicting the &quot;evaluation loop inlining&quot; process described above.  The diagram also shows a third process called &quot;symbolic execution.&quot;  Simply put, symbolic execution is a bridge between interpreter and compiler.  Symbolic execution acts like an interpreter for parsed code, but instead of using real data, data flow is captured and place holders for real information are substituted.  These place holders and their interconnection through the various operations in code, constitute a data flow graph.</P>
<P CLASS="Body">
<A NAME="pgfId=997481">
 </A>
	An initial benefit of symbolic execution would be the removal
            of the stack from the generated code.  The stack would not be required since symbolic execution, in order to create data flow graphs, must simulate the values being pushed on and popped off the stack.  The principles of symbolic execution may be viewed in the following process:</P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId=997482">
 </A>
Partition the byte code into basic blocks.  This is the process of tracking where the goto's and labels are emitted given the stratagem discussed above.  The byte code between the labels and the goto's represent basic blocks.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997483">
 </A>
For each basic block, linearly handle the byte code, similarly to the Python evaluation loop.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997484">
 </A>
For each instruction, simulate the C code found in the Python evaluation loop.  For function calls or even segments of the Python source that can not be simulated, generate data flow operations.  For each pop in the Python C code, pop the data flow node off the simulated stack.  If there is stack underflow, generate a data flow input node as a place holder.  For each push, push the data flow node representing the generation of the value onto the simulated stack.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997485">
 </A>
At the end of a basic block, any data flow nodes remaining on the stack become data outputs for the block.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997486">
 </A>
Thread the inputs and outputs of basic blocks to each other.  This is done using special nodes representing conditional entry, and re-entrant code containers.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Heading2">
<A NAME="pgfId=997488">
 </A>
<A NAME="46870">
 </A>
<A NAME="Methodology_4"></A>
An Example of Symbolic Execution</H3>
<P CLASS="Body">
<A NAME="pgfId=997489">
 </A>
	The above process is not trivial, but it may be more intuitively shown in the following example:</P>
<DIV>
<A NAME="16974"></A>
<MAP NAME="PyFront-3">
</MAP>
<IMG SRC="PyFront-3.gif" USEMAP="#PyFront-3">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=997561">
 </A>
 <A HREF="PyFront.html#16974" CLASS="XRef">Figure 3</A>
 shows an illustration of three things: a sample function (1), a byte code disassembly of the function (2), and a data flow graph (3).  For the purpose of brevity, the sample function is very simple.  There are no jumps in the function, and there is only one operation.  Shown in the second area is an actual &quot;disassembly&quot; of the byte code Python generates for the given function.  The byte code was obtained using the dis.dis routine, as illustrated in the flow.  The final window shows a data flow graph generated from symbolic execution of the byte code, with two operations, two constants, and a value output.</P>
<P CLASS="Body">
<A NAME="pgfId=997562">
 </A>
	To begin symbolic execution in this example, the byte code
              string for the given routine is analyzed (a function's
              byte code string is found in the  co_code attribute of
              the actual function object's func_code attribute, or
              `a.func_code.co_code' in the example.)  In this case,
              the byte code has no jumps, exceptions, and only a
              single return at the end (actually there is a second
              return that is automatically placed at the end of a
              function's byte code that will return None, but since
              this code will never execute, it was omitted from the
              disassembly in <A HREF="PyFront.html#16974"
                CLASS="XRef">figure 3</A>
.)  Since the execution order of the entire function is linear, the byte code shown is the only basic block to be considered.</P>
<P CLASS="Body">
<A NAME="pgfId=997566">
 </A>
	Shown beside the byte code listing for the example function is a stack list.  The stack shown shows the result of symbolic execution of each byte code instruction.  The following would occur during symbolic execution of the byte code:</P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId=997567">
 </A>
The SET_LINENO op code is ignored in this example, but it could also be used during C code generation by setting up a special, sequential data flow representation.  This would allow traceability when debugging the C code. (There is another SET_LINENO for line 1, but there is no code following it, so it was omitted from the op code listing.)</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997568">
 </A>
The `LOAD_FAST 0' op code would reference the first value in the function's locals list, increment its reference count, and push the result onto the value stack.  The function's locals list is initialized by the Python evaluation loop upon entry.  In this case, the value passed for the `b' parameter would be present at that location.  However, the value is not known during symbolic execution, so a `LOAD_FAST' data flow operation node is created, linked to its constant argument (0), and pushed on the stack (represented in the example illustration as `b', but the actual operation is pushed.)</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997569">
 </A>
The `LOAD_CONST 1' op code would reference the second value in the function's constants tuple (referencing these in the `a.func_code.co_consts' value from Python shows that the first constant is None,) increment its reference count, and push the object onto the stack.  Since the symbolic execution routine has the ability to reference the function constants, a constant data node for the number 2 is generated and pushed on the symbolic stack.  This shows a very basic optimization achieved by symbolic execution: if a value is known at analysis time, it will be used by the system.  The symbolic execution routine would remove the overhead required to index into the code object's constants and push any of them onto the stack.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997570">
 </A>
The `BINARY_ADD' op code would pop two values off the stack, perform some type checks to optimize integer addition, add the two values, decrement the reference count of the two popped objects, and push the result of the addition.  Symbolic execution would pop the `LOAD_FAST' operation and the constant value node for 2 off the stack, create a `BINARY_ADD' operation node, build edges from the two data flow inputs to the addition operation, and push the `BINARY_ADD' node just created onto the stack.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=997571">
 </A>
Finally, the `RETURN_VALUE' op code would pop the top of the stack, and break out of the evaluation loop, returning the object.  Since a value is output here, the symbolic execution routine would pop a data flow node off the symbolic stack and build an edge from that node to a newly created `RETURN' node.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=997572">
 </A>
	The data flow graph, with its inputs (downward pointed triangles) and outputs (upward pointed triangles) would then represent how data flows through the given function.  At this point, the graph would be walked in a second pass of symbolic execution.  The second pass would model value assignments and references.  Ideally the second pass would extract such operations as `LOAD_NAME' and `STORE_NAME', by internally maintaining data flow aliases for stores, and building edges to these aliases for later load operations.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading1">
<A NAME="pgfId=997573">
 </A>
<A NAME="Code"></A>
Code Generation</H2>
<P CLASS="Body">
<A NAME="pgfId=997574">
 </A>
	The end result of PyFront is a completed C extension module.
            <A HREF="PyFront.html#65028" CLASS="XRef">Figure
              4</A> shows the template
            used for the output extension code.  The Python extension
            module is broken into four sections: the file prologue,
            the module functions, the method map, and the module
            initialization function.  The models discussed in the <A
              HREF="PyFront.html#70765" CLASS="XRef">
              methodology</A> section are used to generate C code for module
            functions, and the initialization routine, while top level
            analysis is used to integrate the functions with the
            module name space and the method map.</P>


<DIV>
<A NAME="65028"></A>
<MAP NAME="PyFront-4">
</MAP>
<IMG SRC="PyFront-4.gif" USEMAP="#PyFront-4">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=997632">
 </A>
	The file prologue consists of a comment header, an include directive for the PyFront API, and a module constant section.  The comment header simply identifies the source Python code, the version of PyFront used to generate the extension module, and the date of the conversion.  PyFront generated C modules require that only the PyFront API header file is included.  The PyFront API includes the Python API, and will be discussed later.  Finally, a static array of Python object pointers is declared, and a constant initialization routine is generated.</P>
<P CLASS="Body">
<A NAME="pgfId=997633">
 </A>
	In the Python interpreter, constants are instantiated during the byte code conversion process, and serialized as a part of the compiled module.  PyFront initially generated C code that created constants during function initialization, and then destroyed the constants at the end of the function.  The overhead was quickly determined to be undesirable, and constant handling was moved to the module level.  All module constants encountered during PyFront's code analysis process are assigned an index in an array of Python object pointers.  PyFront generates a static routine for instantiation of the constant array as a part of the module prologue.  The constant handler routine is then called by the module initialization function.</P>
<P CLASS="Body">
<A NAME="pgfId=997634">
 </A>
	After the module prologue, functions corresponding to function definitions in the source module are created.  The C code for each function declares a set of Python object pointers, a call to the tuple argument handler, C code for the function, and code for handling various exit conditions.  The function variables replace the object stack, the local variable array, and add the functionality of two registers.  Then, the function arguments are loaded into local variables using the tuple parsing routine, and the function code is generated.</P>
<P CLASS="Body">
<A NAME="pgfId=997635">
 </A>
	Function code is generated using symbolic execution of the byte code instructions.  The byte code instructions may be divided into roughly four categories: control flow, processors, operations, and store operations.  PyFront does not use the control flow op codes, but rather builds control flow models that are translated directly into C flow constructs.  Such byte codes include the &quot;JUMP_IF_FALSE&quot; and &quot;JUMP_FORWARD&quot; instructions.  The second category of instructions are processors.  These op codes do not return a Python object, but rather return an integer error code.  A good example of a processor operation is the &quot;PRINT_ITEM&quot; byte code.  Next, there are operations.  Operations will pop objects off the stack, perform a function on the popped objects, and push an object (or several) back on the stack.  The &quot;BINARY_ADD&quot; instruction is an operation.  Finally, there are store operations that provide interaction between the program name s!
pace and the stack, or solely modi
fy the stack.  These operations include the load and store prefixed op codes and stack modifiers such as &quot;POP_TOP.&quot;</P>
<P CLASS="Body">
<A NAME="pgfId=997708">
 </A>
	During symbolic execution, instructions are dispatched to handler routines that simulate the instruction's stack actions, and build data flow representations.  Currently, C code is generated at this phase of program analysis, generating roughly one function call in C for each instruction.  Since several instructions make one or more Python API calls, and may involve special control logic, PyFront uses its own API.  The PyFront API simply wraps the Python evaluation actions with some minor modifications made to stack dependent code, and includes the Python API.  The PyFront API provides a single function for each Python op code, simplifying code generation, and reduces the size of the C extension code.</P>
<P CLASS="Body">
<A NAME="pgfId=997709">
 </A>
	Error handling is done for each API call emitted, based on the type of the instruction.  Processor instructions return a non-zero value to indicate an error, and are handled as follows:</P>
<P CLASS="DemoCode">
<A NAME="pgfId=997710">
 </A>
if ((err = PyFront_Process (s0, ...)) != 0) goto exit_sx;</P>
<P CLASS="Body">
<A NAME="pgfId=997711">
 </A>
The goto is a reference to an exit label that is determined based on the simulated stack size.  From the target exit handler on, the stack replacement variables are properly deallocated using the DECREF macro.  Operation instructions return a Python object that must be non-NULL, hence a call to an operation instruction handler will appear as follows:</P>
<P CLASS="DemoCode">
<A NAME="pgfId=997712">
 </A>
if ((x = PyFront_Op (s0, ...)) != NULL) goto exit_sx;</P>
<P CLASS="Body">
<A NAME="pgfId=997713">
 </A>
The object returned from the API call is placed first in a &quot;register&quot; variable, which is then moved to the stack simulator variables upon determination of a non-NULL result.  <A HREF="PyFront.html#95639" CLASS="XRef">
Figure 5</A>
 shows an example of the C code generated by PyFront revision 0.4 for the demonstration code in <A HREF="PyFront.html#46870" CLASS="XRef">
figure 3</A>
.</P>
</DIV>
<DIV>
<A NAME="95639"></A>
<MAP NAME="PyFront-5">
</MAP>
<IMG SRC="PyFront-5.gif" USEMAP="#PyFront-5">
</DIV>
<DIV>
<H2 CLASS="Heading1">
<A NAME="pgfId=997721">
 </A>
<A NAME="82022">
 </A>
<A NAME="Results"></A>
Results</H2>
<P CLASS="Body">
<A NAME="pgfId=997722">
 </A>
	The current implementation of PyFront is in its fourth
            revision (0.4,) and consists of a 5,500 line Python to C
            code generator, and a 1,000 line C extension API.  This
            version of PyFront was informally benchmarked against
            Python version 1.5 for performance in simple iterative
            loops and recursive loops.  The benchmarks were run on an
            IBM 43P 604e at 166 Mhz with 64MB RAM under AIX 4.2.1.
            The benchmark functions were implemented in a single 29
            line Python module and converted to a 804 line C file
            (about 27.7 times larger.)  In this case, PyFront was in a
            debug mode that generates comments about the corresponding
            Python code line number and op code (similar to those
            shown in <A HREF="PyFront.html#95639"
              CLASS="XRef">figure 5</A>.)  The extension module
            generated was compiled using IBM C Set++ with
            the same optimization level as was used for the Python
            interpreter.  Times were measured using the Python time
            module and averaged over ten trials.</P>

<P CLASS="Body">
<A NAME="pgfId=997726">
 </A>
	While loop performance was first tested, using the following
            routine:</P>
<PRE>
def while_test (i):
   while i &gt; 0:
      i = i - 1
</PRE>
<P CLASS="Body">
<A NAME="pgfId=997819">
 </A>
<A HREF="PyFront.html#27605" CLASS="XRef">Figure 6</A>
 shows the results of executing the while_test routine over a range of iteration magnitudes.  The data for a thousand iterations shows a very large maximum time trial.  The varied data  may be the result of sensitivity to system resources.  Both Python and PyFront call the PyNumber_FromLong API routine extensively in this test.  At numbers beyond 100, for the Python build used, memory must be allocated for the new integer objects being created by PyNumber_FromLong.  In greater iteration sizes, the variance disappears as the iteration time is larger than the memory allocation overhead.  Ultimately, the while loop proves to be PyFront's strong point, converging at speeds over 2.5 times faster than Python.</P>
<DIV>
<MAP NAME="PyFront-6">
</MAP>
<IMG SRC="PyFront-6.gif" USEMAP="#PyFront-6">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=997820">
 </A>
	The next loop tested was the for loop, which employed the
            following routine:</P>

<PRE>
def for_test (i):
   y = 0
   for x in xrange (0,i):
      y = y + 1
</PRE>
<P CLASS="Body">
<A NAME="pgfId=997911">
 </A>
<A HREF="PyFront.html#53760" CLASS="XRef">Figure 7</A>
 shows the results of running the for_test routine over the same number of iteration magnitudes used for the while loop.  The PyFront implementation of &quot;for&quot; loop logic employs a comparable number of Python API calls to the interpreted version.  The PyFront for loop shows a higher variance in timing data when compared to the while loop, and sometimes exceeds the Python measurements.  Yet at higher iteration counts, the PyFront &quot;for&quot; loop converges at speeds roughly 1.6 times faster than Python.</P>
<DIV>
<A NAME="53760"></A>
<MAP NAME="PyFront-7">
</MAP>
<IMG SRC="PyFront-7.gif" USEMAP="#PyFront-7">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=997912">
 </A>
	The final test used was a recursive loop, that ran the following function:</P>
<P CLASS="DemoCode">
<A NAME="pgfId=997913">
 </A>
<PRE>
def recursive_test (i):
   if (i &gt; 0):
      recursive_test (i - 1)
</PRE>
<P CLASS="Body">
<A NAME="pgfId=997914">
 </A>
	The data taken for the recursive trials was not available for
            higher recursive call sizes due to a frame stack
            limitation built into Python.  <A
              HREF="PyFront.html#46821" CLASS="XRef">Figure
              8</A> shows that PyFront currently introduces a larger
            function call overhead,          running over two times
            slower than the Python recursion            trials.
            Recursion exposes an implementation trade-off in
            the current version of PyFront.  PyFront builds a Python
            code object to wrap the generated C extension functions.
            By generation of a native Python wrapper, function
            arguments (specifically list and keyword arguments) are
            handled correctly, and a frame object is built, providing
            proper traceback information and global name space
            resolution.  It also creates code that effectively makes
            two function calls instead of one (one to the Python
            wrapper function, and one to the C extension function.
            Note that calls from PyFront generated code to other
            Python functions do not add this overhead.  The overhead
            only occurs for calls to PyFront generated functions.)</P>

<DIV>
<A NAME="46821">
</A>
<MAP NAME="PyFront-8"></MAP>
<IMG SRC="PyFront-8.gif" USEMAP="#PyFront-8">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=998001">
 </A>
	Numerical results for the time benchmarks are available in the
            <A HREF="PyFront.html#38223" CLASS="XRef">
              Benchmark Data</A> section.
</P>
</DIV>
<DIV>
<H2 CLASS="Heading1">
<A NAME="pgfId=998005">
 </A>
<A NAME="Future"></A>
Future Directions</H2>
<P CLASS="Body">
<A NAME="pgfId=998006">
 </A>
	Since the current implementation of PyFront is only a prototype, future efforts will focus on building a system that fully meets the objectives of non-intrusion, compatibility, modularity, and optional typing.  Specifically, the current prototype implements correct exception passing, but not exception handling (using the &quot;try-except&quot; and &quot;try-finally&quot; constructs.)  The next goal is to increase the utility of PyFront as an optimization tool.  Finally, as an enhancement to the optimization utility, a proposed typing system will be implemented and tested for compatibility and a low level of intrusion.</P>
<P CLASS="Body">
<A NAME="pgfId=998007">
 </A>
	Completion of Python semantics will require that exception handling code be added to the extension modules generated.  Complicating this objective, &quot;return&quot; and &quot;break&quot; statements may be interrupted by &quot;finally&quot; clauses before they exit their target subroutine or loop.  Therefore, emission of &quot;finally&quot; clauses will require the code generated for &quot;break&quot; and &quot;return&quot; to jump to any &quot;finally&quot; clause rather than the exit point of a given loop or function.  The &quot;finally&quot; exit point will require the use of an exit flag similar to the Python evaluation loop's &quot;why&quot; variable.  The implications for symbolic execution mean that the frame stack must be simulated in addition to the value stack.</P>
<P CLASS="Body">
<A NAME="pgfId=998008">
 </A>
	Once full compatibility is achieved, the second goal is to optimize the PyFront API and generated code.  The current version of PyFront includes the use of local variables for the local name space (which was required to get loop times below Python 1.5 speeds,) and module wide constant initialization.  Future optimizations may include constant folding, common sub-expression elimination, local variable aliases, and type based optimization.  Constant folding would evaluate constant expressions, and generate the resulting constant instead of generating the Python API call.  Common sub-expression elimination would use an operation hashing method to determine when a value may be reused, generating a temporary holding variable in the C code which would be used instead of performing redundant computation.  Local variable aliases would simulate the local variable name space during symbolic execution, allowing any constant assignments to propagate through and be folded where appropri!
ate.</P>
<P CLASS="Body">
<A NAME="pgfId=998009">
 </A>
	Finally, type based optimizations will be prototyped in PyFront.  The data flow graph built by PyFront provides a means for propagation of constant types, but would most likely be unable to consistently resolve the type of inputs and variables.  PyFront would address the type resolution problem by providing a type extension scheme.  The proposed type extension scheme would involve the insertion of a uniquely named dictionary at the top level of a module.  The dictionary would map from regular expressions to strings containing type information.  When a name is referenced during symbolic execution, the type system would attempt to match the label to one of the regular expression keys in the type dictionary.  If type information was available, it would be used to select type specific operations, circumventing Python API calls.  Otherwise, the standard Python API call would be emitted as already done by the current PyFront.</P>
<P CLASS="Body">
<A NAME="pgfId=998010">
 </A>
	The PyFront type dictionary would offer the following features:</P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId=998011">
 </A>
Non-intrusive: The type dictionary would be parsed by Python as a normal module member.  Specifically, the type dictionary would map a set of strings to strings, requiring no additional constructs, keywords, or import modules.  The dictionary's presence would simply add some byte code overhead to the module, and would not change the module's semantics as a Python script.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=998012">
 </A>
Self documenting:  By using regular expressions as keys in the type dictionary, variable naming conventions could be employed in a similar fashion to currently used naming conventions (such as Hungarian prefix notation) [Simonyi.]  These naming conventions, assuming some standard was followed, would increase code readability and type consistency even without the use of PyFront.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId=998013">
 </A>
Optional: The type dictionary would provide the opportunity to define
              types down to specific variables, but would not be
              required to use PyFront.</LI>

</UL>
<P CLASS="Body">
<A NAME="pgfId=998014">
 </A>
For example, Hungarian notation uses a &quot;n&quot; prefix for
            integers.  In PyFront, adding a line such as
            &quot;__pyf_type_dict = {`n[A-Za-z0-9_]*' : `int'}&quot;
            would implement the integer prefix association.  The prime
            drawback to this system (as any similar type system) is
            that legacy Python code would have to be modified to take
            advantage of type optimizations.</P>

<P CLASS="Body">
<A NAME="pgfId=998015">
 </A>
	A final note about the type system: it could be used to
            express such concepts as static module variables (allowing
            global variables to be optimized in a similar fashion to
            local variables,) or even constance (allowing global
            constant assignments to be treated like macros.)  If these
            type extensions were employed, recursive calls and calls
            to other functions in the module could be replaced by
            direct calls to the C function, eliminating the recursive
            call overhead seen in the 
            <A HREF="PyFront.html#82022"
              CLASS="XRef">Results</A> section.
</P>
</DIV>
<DIV>
<H2 CLASS="Heading1">
<A NAME="pgfId=998019">
 </A>
<A NAME="Conclusion"></A>
Conclusion</H2>
<P CLASS="Body">
<A NAME="pgfId=998020">
 </A>
            By translating Python control flow into C control flow,
            replacing the Python value stack with C variables, and
            inlining Python API calls normally made by the Python
            interpreter, PyFront achieves modest increases in Python
            script performance.  While certain design trade-offs in
            the current implementation add overhead to calling
            converted functions, they are also needed to assist
            PyFront with its goal of compatibility.  As these
            trade-offs are weighed and future plans are implemented,
            PyFront performance should continue to improve.  Further
            development of such features as the proposed type system
            will enable PyFront to provide a non-intrusive, and mostly
            automatic path from Python modules to faster and
            statically compiled C code.</P>
</DIV>
<DIV>
<H2 CLASS="Heading1">
<A NAME="pgfId=998021">
</A>
<A NAME="Works"></A>
Works Cited</H2>
<P CLASS="Body">
<A NAME="pgfId=998022">
 </A>
Aho, A.V., Sethi, R., and Ulman, J.D.  <CITE>Compilers: Principles, Techniques, and Tools.</CITE>  Computer Science Series.  Reading, Massachusetts: Addison-Wesley, 1986.</P>
<P CLASS="Body">
<A NAME="pgfId=998023">
 </A>
Fly, Charles. &quot;Grammar-based Rapid Application Development.&quot;
<A HREF="http://www.python.org/workshops/1996-11/papers/GRAD/html/GRADpaper.book.html">http://www.python.org/workshops/1996-11/papers/GRAD/html/GRADpaper.book.html</A>
</P>
<P CLASS="Body">
<A NAME="pgfId=998024">
 </A>
Simonyi, Charles.  &quot;Program Identifier Naming Conventions.&quot;
<A HREF="http://www.strangecreations.com/library/c/naming.txt">http://www.strangecreations.com/library/c/naming.txt</A>
</P>
<P CLASS="Body">
<A NAME="pgfId=998025">
 </A>
Van Rossum, Guido.  <CITE>Python/C API Reference Manual.</CITE>  Reston, Virginia: Corporation for National Research Initiatives, December 31, 1997.</P>
<P CLASS="Body">
<A NAME="pgfId=998026">
 </A>
Weise, D., Crew R., Ernst, M., and Steensguard, B.  &quot;Value Dependence Graphs: Representation Without Taxation.&quot;  In Principles of Programming Languages, pages 297-310.  Portland, Oregon: ACM Press, January 1994.</P>
</DIV>
<DIV>
<H2 CLASS="Heading1">
<A NAME="pgfId=998374">
 </A>
<A NAME="38223">
 </A>
<A NAME="Data"></A>
Benchmark Data</H2>
<H3>
<A NAME="pgfId=998030">
 </A>
Results of while_test benchmark in seconds.</H3>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998040">
 </A>
System</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998042">
 </A>
Average</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998044">
 </A>
Maximum</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998046">
 </A>
Minimum</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998048">
 </A>
i</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998050">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998052">
 </A>
0.000151</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998054">
 </A>
0.000237</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998056">
 </A>
0.000140</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998058">
 </A>
100</P>
<P CLASS="CellBody">
<A NAME="pgfId=998059">
 </A>
&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998061">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998063">
 </A>
0.000299</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998065">
 </A>
0.000327</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998067">
 </A>
0.000295</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998071">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998073">
 </A>
0.003176</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998075">
 </A>
0.020530</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998077">
 </A>
0.001099</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998079">
 </A>
1000</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998081">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998083">
 </A>
0.003690</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998085">
 </A>
0.012221</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998087">
 </A>
0.002732</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998091">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998093">
 </A>
0.010875</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998095">
 </A>
0.011622</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998097">
 </A>
0.010723</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998099">
 </A>
10000</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998101">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998103">
 </A>
0.027499</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998105">
 </A>
0.028712</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998107">
 </A>
0.027156</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998111">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998113">
 </A>
0.108263</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998115">
 </A>
0.110256</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998117">
 </A>
0.106739</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998119">
 </A>
100000</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998121">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998123">
 </A>
0.276231</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998125">
 </A>
0.282810</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998127">
 </A>
0.273740</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998131">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998133">
 </A>
1.081822</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998135">
 </A>
1.089260</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998137">
 </A>
1.078540</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998139">
 </A>
1000000<BR>
(not illustrated.)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998141">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998143">
 </A>
2.755389</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998145">
 </A>
2.828164</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998147">
 </A>
2.744902</P>
</TD>
</TR>
</TABLE>
<H3>
<A NAME="pgfId=998152">
 </A>
Results of for_test benchmark in seconds.</H3>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998162">
 </A>
System</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998164">
 </A>
Average</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998166">
 </A>
Maximum</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998168">
 </A>
Minimum</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998170">
 </A>
i</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998172">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998174">
 </A>
0.000257</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998176">
 </A>
0.000444</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998178">
 </A>
0.000234</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998180">
 </A>
100</P>
<P CLASS="CellBody">
<A NAME="pgfId=998181">
 </A>
&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998183">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998185">
 </A>
0.000330</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998187">
 </A>
0.000358</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998189">
 </A>
0.000326</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998193">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998195">
 </A>
0.002122</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998197">
 </A>
0.002833</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998199">
 </A>
0.002020</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998201">
 </A>
1000</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998203">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998205">
 </A>
0.003060</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998207">
 </A>
0.003086</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998209">
 </A>
0.003050</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998213">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998215">
 </A>
0.022115</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998217">
 </A>
0.040743</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998219">
 </A>
0.019935</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998221">
 </A>
10000</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998223">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998225">
 </A>
0.030748</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998227">
 </A>
0.031951</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998229">
 </A>
0.030324</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998233">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998235">
 </A>
0.203508</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998237">
 </A>
0.213573</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998239">
 </A>
0.200051</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998241">
 </A>
100000</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998243">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998245">
 </A>
0.307384</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998247">
 </A>
0.309501</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998249">
 </A>
0.305754</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998253">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998255">
 </A>
2.019005</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998257">
 </A>
2.026224</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998259">
 </A>
2.012978</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998261">
 </A>
1000000<BR>
(not illustrated.)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998263">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998265">
 </A>
3.079594</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998267">
 </A>
3.130966</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998269">
 </A>
3.067530</P>
</TD>
</TR>
</TABLE>
<H3>
<A NAME="pgfId=998274">
 </A>
<BR>
Results of recursive_test benchmark in seconds.</H3>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998284">
 </A>
System</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998286">
 </A>
Average</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998288">
 </A>
Maximum</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998290">
 </A>
Minimum</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId=998292">
 </A>
i</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998294">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998296">
 </A>
0.002010</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998298">
 </A>
0.002934</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998300">
 </A>
0.001886</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998302">
 </A>
100</P>
<P CLASS="CellBody">
<A NAME="pgfId=998303">
 </A>
&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998305">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998307">
 </A>
0.000949</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998309">
 </A>
0.001040</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998311">
 </A>
0.000936</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998315">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998317">
 </A>
0.034421</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998319">
 </A>
0.049501</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998321">
 </A>
0.031700</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998323">
 </A>
1000</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998325">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998327">
 </A>
0.013491</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998329">
 </A>
0.015399</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998331">
 </A>
0.013080</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998335">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998337">
 </A>
0.078262</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998339">
 </A>
0.080017</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998341">
 </A>
0.076403</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998343">
 </A>
2000</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998345">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998347">
 </A>
0.031356</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998349">
 </A>
0.033385</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998351">
 </A>
0.030542</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998355">
 </A>
PyFront</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998357">
 </A>
0.177236</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998359">
 </A>
0.188143</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998361">
 </A>
0.171520</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998363">
 </A>
4000</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998365">
 </A>
Python</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998367">
 </A>
0.075773</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998369">
 </A>
0.080134</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=998371">
 </A>
0.072615</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=998375">
 </A>
&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=997357">
 </A>
&nbsp;</P>
</DIV>
</DIV>
</BODY>

<!-- SOME LINK HREF'S ON THIS PAGE HAVE BEEN REWRITTEN BY THE WAYBACK MACHINE
OF THE INTERNET ARCHIVE IN ORDER TO PRESERVE THE TEMPORAL INTEGRITY OF THE SESSION. -->


<SCRIPT language="Javascript">
<!--

// FILE ARCHIVED ON 20010702174220 AND RETRIEVED FROM THE
// INTERNET ARCHIVE ON 20060504134643.
// JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.
// ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
// SECTION 108(a)(3)).

   var sWayBackCGI = "http://web.archive.org/web/20010702174220/";

   function xLateUrl(aCollection, sProp) {
      var i = 0;
      for(i = 0; i < aCollection.length; i++)
         if (aCollection[i][sProp].indexOf("mailto:") == -1 &&
             aCollection[i][sProp].indexOf("javascript:") == -1)
            aCollection[i][sProp] = sWayBackCGI + aCollection[i][sProp];
   }

   if (document.links)  xLateUrl(document.links, "href");
   if (document.images) xLateUrl(document.images, "src");
   if (document.embeds) xLateUrl(document.embeds, "src");

   if (document.body && document.body.background)
      document.body.background = sWayBackCGI + document.body.background;

//-->

</SCRIPT>
</HTML>

